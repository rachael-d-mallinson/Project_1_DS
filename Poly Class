package polynomialAddition;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.ListIterator;

public class Poly extends Term {

	// Data fields
	private ArrayList<Term> listOfTerms;

	// Constructors
	public Poly() {} // Default Constructor

	public Poly(ArrayList<Term> listOfTerms) { this.listOfTerms = listOfTerms; }

	// Getter
	public ArrayList<Term> getPoly() { return listOfTerms; }

	// Setter
	public void setPoly(ArrayList<Term> list) { listOfTerms = list; }

	// Methods

	/**
	 * Finds the Term with the largest exponent in the passed in ArrayList of Terms
	 * @param poly: the ArrayList of Terms
	 * @return: Term with the largest exponent
	 */
	public Term findMaxTerm(ArrayList<Term> poly) {
		Iterator<Term> iterator = poly.iterator();
		int maxExp = Integer.MIN_VALUE;
		Term maxTerm = null;

		while (iterator.hasNext()) {
			Term tempTerm = iterator.next();
			int temp = tempTerm.getExponent();
			if (temp > maxExp) {
				maxExp = temp;
				maxTerm = tempTerm;
			}
		}
		return maxTerm;
	}

	/**
	 * Sorted the ArrayList of polynomial terms by largest to smallest
	 * @param poly: the ArrayList of Terms
	 * @return sortedList: A sorted ArrayList of passed in terms by largest exponent to smallest
	 */
	public ArrayList<Term> sort(ArrayList<Term> poly) {
		ArrayList<Term> sortedList = new ArrayList<>();
		Iterator<Term> iterator = poly.iterator();

		if (poly != null) {
			while (iterator.hasNext()) {
				Term maxTerm = findMaxTerm(poly);
				sortedList.add(maxTerm);
				poly.remove(maxTerm);
			}
		}
		return sortedList;
	} // Time complexity: O(n^2)

	/**
	 * Reduces (adds) like terms inside the added polynomial ArrayList
	 * @param poly: the sorted ArrayList containing all the Terms of both polynomials
	 * @return: The sum of both polynomials with all like Terms added together
	 */
	public static ArrayList<Term> sumPolynomial(ArrayList<Term> poly) {
		ArrayList<Term> reducedList = new ArrayList<>();
		ListIterator<Term> iterator = poly.listIterator();

		if (poly != null) {
			while (iterator.hasNext()) {
				Term q = iterator.next();
				if (!iterator.hasNext()) {
					reducedList.add(q);
					break;
				} else if (q.compareTo(iterator.next()) == 0) {
					Term p = iterator.previous();
					Term reduced = q.reduceLikeTerms(p);
					if (reduced.getCoefficient() == 0) {
						iterator.next();
						continue;
					} else { reducedList.add(reduced); }
					iterator.next();
				} else {
					iterator.previous();
					reducedList.add(q);
				}
			}
		}
		return reducedList;
	}
}
